#!/usr/bin/env python3

from posixpath import pathsep
import arbor as A
import subprocess as sp
import sys
from tempfile import mkdtemp
import os
from pathlib import Path
import shutil
import argparse
import re

class Config:
    def find_dirs(self):
        paths = [
                self.prefix,                          # likely install prefix, possibly overridden
                self.arb,                             # base dir of arbor package
                self.arb.parent.parent.parent.parent, # base dir of venv
        ]
        for dn in paths:
            bindir = Path(dn) / self.bin
            pakdir = Path(dn) / self.lib / "cmake" / "arbor"

            if all(
                    p.exists()
                    for p in [
                bindir / "modcc",
                pakdir / "arbor-config.cmake",
            ]
        ):
                 self._bindir = bindir
                 self._pakdir = pakdir
                 return
        raise FileNotFoundError(
            f"Could not find required tools in {paths}. Please check your installation."
        )

    @property
    def bin(self):
        return self._bin

    @bin.setter
    def bin(self, val):
        self._pakdir = None
        self._bindir = None
        self._bin = val

    @property
    def lib(self):
        return self._lib

    @lib.setter
    def lib(self, val):
        self._pakdir = None
        self._bindir = None
        self._lib = val

    @property
    def bindir(self):
        if not self._bindir:
            self.find_dirs()
        return self._bindir

    @property
    def pakdir(self):
        if not self._pakdir:
            self.find_dirs()
        return self._pakdir

    @property
    def gpu(self):
        return self._gpu

    @gpu.setter
    def gpu(self, gpu):
        if gpu:
            self._gpu = gpu
        else:
            self._gpu = "none"

    @property
    def name(self):
        return self._name

    @name.setter
    def name(self, name):
        self._name = re.sub(r"_+", r"_", re.sub(r"[^a-zA-Z0-9_]", r"_", name))

    @property
    def mods(self):
        return [f[:-4] for f in os.listdir(self.cwd / self.mod_dir) if f.endswith(".mod")]


    @property
    def cxx(self):
        return self._cxx

    @cxx.setter
    def cxx(self, val):
        cxx = Path(val)
        if not cxx.exists():
            # Example <>/lib/python3.10/site-packages/arbor
            altern = "c++"
            from shutil import which

            if which(altern) == None:
                print(
                    f"Error: Neither prefix '{self.cxx}' nor fallback '{altern}' exist. Please provide a path to a C++ compiler with --cxx",
                    file=sys.stderr,
                )
                exit(-1)
            print(
                f"Warning: prefix '{self.cxx}' does not exist, falling back to '{altern}'.",
                file=sys.stderr,
            )
            self._cxx = altern
        else:
            self._cxx = cxx



    @property
    def verbosity(self):
        verbosity = 0
        if self.verbose:
            verbosity = 1
        if self.quiet:
            verbosity = -1
        return verbosity


    def __init__(self):
        config = A.config()
        self.quiet = False
        self.cpu = True
        self.verbose = False
        self.bin = config['binary_path']
        self.lib = config['lib_path']
        self.raws = []
        self.mod_dir = None
        self._pakdir = None
        self._bindir = None
        self.prefix = Path(config["prefix"])
        self.cxx = Path(config["CXX"])
        self.gpu = config['gpu']
        self.cwd = Path.cwd()
        self.out = self.cwd
        self.debug = None
        self.arb = Path(list(A.__path__)[0])


def parse_arguments():
    config = Config()

    parser = argparse.ArgumentParser(
        description="Generate dynamic catalogue and build it into a shared object.",
        usage="%(prog)s catalogue_name mod_source_dir",
        add_help=False,
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
    )

    parser.add_argument("name", metavar="name", type=str, help="Catalogue name.")

    parser.add_argument(
        "--raw",
        metavar="raw",
        nargs="+",
        default=[],
        type=str,
        help="""Raw C++ mechanisms; per <name> the files <name>.hpp,
<name>_cpu.cpp (if CPU enabled), <name>_gpu.cpp and <name>_gpu.cu (if GPU
enabled) must be present in the target directory.""",
    )

    parser.add_argument(
        "modpfx",
        metavar="modpfx",
        type=str,
        help="Directory name where *.mod files live.",
    )

    parser.add_argument("-v", "--verbose", action="store_true", help="Verbose.")

    parser.add_argument("-q", "--quiet", action="store_true", help="Less output.")

    parser.add_argument("--cpu", default=True, help="Enable CPU support.")

    parser.add_argument(
        "--debug",
        nargs="?",
        metavar="path",
        const=True,
        default=None,
        help="Don't clean up the generated temp cpp code."
        + " Can be a target path for the generated code.",
    )

    parser.add_argument(
        "--gpu",
        metavar="gpu",
        default=config.gpu if config.gpu else "none",
        choices=["none", "cuda", "hip", "cuda-clang"],
        help=f"Enable GPU support",
    )

    parser.add_argument(
        "--cxx",
        metavar="cxx",
        default=config.cxx,
        help="Use this C++ compiler.",
    )

    parser.add_argument(
        "--prefix",
        metavar="prefix",
        default=config.prefix,
        help="Arbor's install prefix.",
    )

    parser.add_argument(
        "--bin",
        metavar="bin",
        default=config.bin,
        help="Look here for Arbor utils like modcc; relative to prefix.",
    )

    parser.add_argument(
        "--lib",
        metavar="lib",
        default=config.lib,
        help="Look here for Arbor's CMake config; relative to prefix.",
    )

    parser.add_argument(
        "-h", "--help", action="help", help="Display this help and exit."
    )

    res =  vars(parser.parse_args())
    config.name = res['name']
    config.lib = res['lib']
    config.bin = res['bin']
    config.prefix = res['prefix']
    config.gpu = res['gpu']
    config.cpu = res['cpu']
    config.verbose = res['verbose']
    config.debug = res['debug']
    config.quiet = res['quiet']
    config.raws = res['raw']
    config.mod_dir = Path.cwd() / res['modpfx']
    return config


def make_gpu_support(gpu, cxx):
    if gpu == "cuda":
        gpu_support = f"""
include(FindCUDAToolkit)
add_compile_definitions(ARB_CUDA)
add_compile_definitions(ARB_HAVE_GPU)
find_package(CUDAToolkit)
enable_language(CUDA)
set(CMAKE_CUDA_STANDARD 14)

set(CMAKE_CUDA_HOST_COMPILER {cxx})
"""
    elif gpu == "cuda-clang":
        gpu_support = f"""
add_compile_definitions(ARB_CUDA)
add_compile_definitions(ARB_HAVE_GPU)
find_package(CUDAToolkit)
enable_language(CUDA)
set(CMAKE_CUDA_STANDARD 14)
add_compile_options(-xcuda --cuda-gpu-arch=sm_60 --cuda-gpu-arch=sm_70 --cuda-gpu-arch=sm_80 --cuda-path=${{CUDA_TOOLKIT_ROOT_DIR}}))
"""
    elif gpu == "hip":
        gpu_support = f"""
add_compile_definitions(ARB_HIP)
add_compile_definitions(ARB_HAVE_GPU)
add_compile_options(-xhip --amdgpu-target=gfx906 --amdgpu-target=gfx900)
"""
    elif gpu == "none":
        gpu_support = """
# GPU: Disabled
"""
    else:
        raise RuntimeError(f"Internal Error: Unknown GPU type: {gpu}")
    return gpu_support

def make_cmake(config):
    gpu = make_gpu_support(cxx=config.cxx, gpu=config.gpu)
    return f"""cmake_minimum_required(VERSION 3.9)
project({config.name}-cat LANGUAGES CXX)
set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
set(CMAKE_CXX_EXTENSIONS OFF)

set(arbor_DIR {config.pakdir})
find_package(arbor REQUIRED)
{gpu}
set(CMAKE_BUILD_TYPE release)
set(CMAKE_CXX_COMPILER  {config.cxx})
set(CMAKE_CXX_FLAGS     ${{ARB_CXX_FLAGS}})

set(ARB_WITH_EXTERNAL_MODCC true)
find_program(modcc NAMES modcc PATHS {config.bindir})

function("make_catalogue_standalone")
  cmake_parse_arguments(MK_CAT "" "NAME;SOURCES;VERBOSE" "CXX_FLAGS_TARGET;MOD;CXX" ${{ARGN}})
  set(MK_CAT_OUT_DIR "${{CMAKE_CURRENT_BINARY_DIR}}/generated/${{MK_CAT_NAME}}")
  file(MAKE_DIRECTORY "${{MK_CAT_OUT_DIR}}")

  if(MK_CAT_VERBOSE)
    message("Catalogue name:       ${{MK_CAT_NAME}}")
    message("Catalogue mechanisms: ${{MK_CAT_MOD}}")
    message("Extra cxx files:      ${{MK_CAT_CXX}}")
    message("Catalogue sources:    ${{MK_CAT_SOURCES}}")
    message("Catalogue output:     ${{MK_CAT_OUT_DIR}}")
    message("Arbor cxx flags:      ${{MK_CAT_CXX_FLAGS_TARGET}}")
    message("Arbor cxx compiler:   ${{ARB_CXX}}")
    message("Current cxx compiler: ${{CMAKE_CXX_COMPILER}}")
  endif()

  set(mk_cat_modcc_flags -t cpu ${{ARB_MODCC_FLAGS}} -N arb -c ${{MK_CAT_NAME}} -o ${{MK_CAT_OUT_DIR}})
  if(ARB_WITH_GPU)
    set(mk_cat_modcc_flags -t gpu ${{mk_cat_modcc_flags}})
  endif()

  set(catalogue_${{MK_CAT_NAME}}_source ${{MK_CAT_OUT_DIR}}/${{MK_CAT_NAME}}_catalogue.cpp)

  foreach(mech ${{MK_CAT_MOD}})
    list(APPEND catalogue_${{MK_CAT_NAME}}_mods ${{MK_CAT_SOURCES}}/${{mech}}.mod)
    list(APPEND catalogue_${{MK_CAT_NAME}}_source ${{MK_CAT_OUT_DIR}}/${{mech}}_cpu.cpp)
    if(ARB_WITH_GPU)
      list(APPEND catalogue_${{MK_CAT_NAME}}_source ${{MK_CAT_OUT_DIR}}/${{mech}}_gpu.cpp ${{MK_CAT_OUT_DIR}}/${{mech}}_gpu.cu)
    endif()
  endforeach()

  foreach(mech ${{MK_CAT_CXX}})
    set(mk_cat_modcc_flags -r ${{mech}} ${{mk_cat_modcc_flags}})
  endforeach()

  add_custom_command(OUTPUT            ${{catalogue_${{MK_CAT_NAME}}_source}}
                     DEPENDS           ${{catalogue_${{MK_CAT_NAME}}_mods}}
                     WORKING_DIRECTORY ${{CMAKE_CURRENT_SOURCE_DIR}}
                     COMMAND ${{modcc}} ${{mk_cat_modcc_flags}} ${{catalogue_${{MK_CAT_NAME}}_mods}}
                     COMMENT "modcc generating: ${{catalogue_${{MK_CAT_NAME}}_source}}")

  foreach(mech ${{MK_CAT_CXX}})
    list(APPEND catalogue_${{MK_CAT_NAME}}_source ${{MK_CAT_OUT_DIR}}/${{mech}}_cpu.cpp)
    if(ARB_WITH_GPU)
      list(APPEND catalogue_${{MK_CAT_NAME}}_source ${{MK_CAT_OUT_DIR}}/${{mech}}_gpu.cpp ${{MK_CAT_OUT_DIR}}/${{mech}}_gpu.cu)
    endif()
  endforeach()

  if(ARB_WITH_CUDA_CLANG OR ARB_WITH_HIP_CLANG)
    set_source_files_properties(${{catalogue_${{MK_CAT_NAME}}_source}} DIRECTORY ${{CMAKE_CURRENT_SOURCE_DIR}} PROPERTIES LANGUAGE CXX)
  endif()

  add_library(${{MK_CAT_NAME}}-catalogue SHARED ${{catalogue_${{MK_CAT_NAME}}_source}})
  target_compile_definitions(${{MK_CAT_NAME}}-catalogue PUBLIC STANDALONE=1)

  if(ARB_WITH_GPU)
    target_compile_definitions(${{MK_CAT_NAME}}-catalogue PUBLIC ARB_GPU_ENABLED)
  endif()

  target_compile_options(${{MK_CAT_NAME}}-catalogue PUBLIC ${{MK_CAT_CXX_FLAGS_TARGET}})
  set_target_properties(${{MK_CAT_NAME}}-catalogue
    PROPERTIES
    SUFFIX ".so"
    PREFIX ""
    CXX_STANDARD 17)
  target_link_libraries(${{MK_CAT_NAME}}-catalogue PRIVATE arbor::arbor)
endfunction()


make_catalogue_standalone(
  NAME {config.name}
  SOURCES "${{CMAKE_CURRENT_SOURCE_DIR}}/mod"
  MOD {' '.join(config.mods)}
  CXX {' '.join(config.raws)}
  CXX_FLAGS_TARGET ${{ARB_CXX_FLAGS_TARGET}}
  VERBOSE {"ON" if config.verbose > 1 else "OFF"})
"""


def run(config):
    if config.verbosity > 1:
        print(f"Building catalogue '{config.name}' from mechanisms in {config.mod_dir}")
        if config.debug:
            print("Debug mode enabled.")
        if config.mods:
            print(" * NMODL")
            for m in config.mods:
                print("   *", m)
        if config.raws:
            print(" * Raw")
            for m in config.raws:
                print("   *", m)

    if config.debug:
        # Overwrite the local reference to `TemporaryDirectory` with a context
        # manager that doesn't clean up the build folder so that the generated cpp
        # code can be debugged
        class TemporaryDirectory:
            def __enter__(*args, **kwargs):
                if isinstance(config.debug, str):
                    path = os.path.abspath(config.debug)
                    try:
                        os.makedirs(path, exist_ok=False)
                    except FileExistsError:
                        sys.stderr.write(
                            f"Error: Debug destination '{path}' already exists.\n"
                        )
                        sys.stderr.flush()
                        exit(1)
                else:
                    path = mkdtemp()
                print(f"Building debug code in '{path}'.")
                return path

            def __exit__(*args, **kwargs):
                pass

    else:
        from tempfile import TemporaryDirectory

    with TemporaryDirectory() as tmp:
        tmp = Path(tmp)
        shutil.copytree(config.mod_dir, tmp / "mod")
        os.mkdir(tmp / "build")
        os.chdir(tmp / "build")
        with open(tmp / "CMakeLists.txt", "w") as fd:
            fd.write(
                make_cmake(config)
            )

        out = tmp / "build" / "generated" / config.name
        os.makedirs(out, exist_ok=True)
        sfx = [".hpp"]
        if config.cpu:
            sfx += ["_cpu.cpp"]
        if config.gpu != "none":
            sfx += ["_gpu.cpp", "_gpu.cu"]
        for e in config.raws:
            for s in sfx:
                fn = config.mod_dir / (e + s)
                if not fn.exists():
                    print(
                        f"Could not find required file: {fn}. Please check your C++ mechanisms."
                    )
                    exit(-1)
                else:
                    shutil.copy2(fn, out / (e + s))

        cmake_cmd = "cmake .."
        make_cmd = "make"
        if config.verbosity > 1:
            make_cmd += " VERBOSE=1"
        try:
            sp.run(cmake_cmd, shell=True, check=True, capture_output=True, text=True)
            sp.run(make_cmd, shell=True, check=True, capture_output=True, text=True)
            shutil.copy2(f"{config.name}-catalogue.so", config.out)
        except sp.CalledProcessError as e:
            import traceback as tb

            if config.verbosity <= 0:
                # Not in verbose mode, so we have captured the
                # `stdout` and `stderr` and can print it to the user.
                sys.stdout.write("Build log:\n")
                sys.stdout.write(e.stdout)
                sys.stderr.write(tb.format_exc() + " Error:\n\n")
                sys.stderr.write(e.stderr)
            else:
                # In verbose mode the outputs weren't captured and
                # have been streamed to `stdout` and `stderr` already.
                sys.stderr.write(
                    "Catalogue building error occurred."
                    + " Check stdout log for underlying error,"
                    + " or omit verbose flag to capture it."
                )
            sys.stdout.flush()
            sys.stderr.flush()
            exit(e.returncode)
    if not config.verbosity < 0:
        print(f"Catalogue has been built and copied to {config.out}/{config.name}-catalogue.so")


def cli():
    config = parse_arguments()
    run(config)


if __name__ == "__main__":
    cli()
